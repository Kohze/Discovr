{
    "collab_server" : "",
    "contents" : "#' @title discovr()\n#' @author Robin Kohze\n#' @param x A data.frame or data.table\n#' @param method The method indicates \"paired\" or \"unpaired\" testing\n#' @param preset As preset mutliple techniques are allowed, such as \"FACS\" or \"FRAP\".\n#' @param style A style input such as \"heatmap\" / \"cleveland\" / \"ternary\" \n#' @return The calculation output\n#' @include graphics.R\n#' @include statisticFun.R\n#' @import future\n#' @import d3three\n#' @import jsonlite\n#' @examples \n#' disc(mtcars)\n#' @export\ndisc <- function(x, method = \"unPaired\", preset = NULL){\n  input = as.data.frame(x)\n  colNames = paste(names(x), collapse = \" \")\n  dataSetName = deparse(substitute(x))\n  \n  return(d4_three(graphicGen(methodChoice(method, input), method, colNames, dataSetName)))\n}\n\n#' output of numerical values\n#' @param x is the dataframe input \n#' @param method is \"paired\" or \"unPaired\"\n#' @param preset is the invididual choosen preset (\"facs\",\"frap\")\n#' @return returns modified data output specific for the choosen method\n#' @export\ndisc.data <- function(x, method = \"unPaired\", preset = NULL){\n  input = as.data.frame(x)\n  preOut = methodChoice(method, input)\n  \n  preVec = fromJSON(preOut$x1)\n  preVec2 = fromJSON(preOut$x8)\n  preVec3 = fromJSON(preOut$x9)\n  \n  preOut$x1 = preVec$children\n  preOut$x8 = preVec2$children\n  preOut$x9 = preVec3$children\n  \n  #future module: different naming if paired/unpaired distinct methods.\n   if(method == \"paired\"){\n     names(preOut) = c(\n       \"shapiro.test\",\n       \"correlation.test\",\n       \"f.test\",\n       \"anova.test\",\n       \"student.test\",\n       \"welch.test\",\n       \"wilcoxon.test\",\n       \"pca\",\n       \"glm\"\n    )\n   } else {\n    names(preOut) = c(\n      \"shapiro.test\",\n      \"correlation.test\",\n      \"f.test\",\n      \"anova.test\",\n      \"student.test\",\n      \"welch.test\",\n      \"wilcoxon.test\",\n      \"pca\",\n      \"glm\"\n    ) \n   }\n  \n  return(preOut)\n}\n\n#' function for the preset usage\n#' @param presetApp is the input for the specific preset\n#' @return returns modified data output specific for the choosen preset\npresetFunction <- function(presetApp, x) {\n  output = switch(presetApp, \n         facs = log(x),\n         FACS = log(x),\n         frap = cat(\"The frap algorithm from FRAPBOT will be included soon\"),\n         FRAP = cat(\"The frap algorithm from FRAPBOT will be included soon\"),\n         NULL = x)\n  return(output)\n}\n\n#' splitts calculation in paired and unpaired sections\n#' @param method is the method parameter and the \n#' @param input is the data.frame\n#' @return returns the statistical calculations for each section\ndataAdjust <- function(a){\n  result = expand.grid(a = colnames(a), b = colnames(a))\n  result$c[result$a == result$b] = TRUE\n  result$c[result$a != result$b] = FALSE\n  result = result[!result$c,]\n  \n  for(i in 1:nrow(result)){\n    result$data[i] = a[result$a[i],result$b[i]]\n  }\n  \n  result$duplicated = duplicated(result$data)\n  \n  for(i in 1:nrow(result)){\n    if(result$duplicated[i] == FALSE) {\n      result$output[i] = paste(result$a[i],result$b[i], collapse = \"/\")\n    } else {\n      result$output[i] = paste(result$b[i],result$a[i], collapse = \"/\")\n    }\n  }\n  \n  bed = result[result$duplicated == FALSE & !is.na(result$data),]\n  bed$data = abs(bed$data)\n  \n  preOutput = data.frame(\"name\" = bed$output, \"size\" = bed$data)\n  output = toJSON(list(\"name\" = \"query\", \"children\" = preOutput), pretty = TRUE)\n  \n  return(output)\n}\n\n#' function to recover data from JSON list\n#' @param input is the specific JSON list dataset\n#' @return returns the recovered data.frame\n\nlistOut <- function(input){\n  preVec = fromJSON(input)\n  preOut = preVec$children\n  return(preOut$size)\n}\n\n#' function to convert a value to color\n#' @param input is the specific method output\n#' @param bigger indicates if the \"wanted\" value is > or < 0.05\n#' @return returns the color name\ncolorTransla <- function(input, bigger = TRUE, minp = 0.05){\n\n  if(bigger == TRUE){\n    x = length(which( input > minp))/length(input)\n  } else {\n    x = length(which( input < minp))/length(input)\n  }\n  \n  colorRange <- colorRampPalette(c(\"red\",\"grey\",\"green\"))\n  col = colorRange(100)\n  x = round(x * 100)\n  return(col[x])\n}  \n\n#' splitts calculation in paired and unpaired sections\n#' @param method is the method parameter and the \n#' @param input is the data.frame\n#' @return returns the statistical calculations for each section\ngraphicGen <- function(x, method, colNames, dataSetName){\n  x1 = x[[\"x1\"]]\n  x2 = dataAdjust(x[[\"x2\"]])\n  x3 = dataAdjust(x[[\"x3\"]])\n  x4 = dataAdjust(x[[\"x4\"]])\n  x5 = dataAdjust(x[[\"x5\"]])\n  x6 = dataAdjust(x[[\"x6\"]])\n  x7 = dataAdjust(x[[\"x7\"]])\n  x8 = x[[\"x8\"]]\n  x9 = x[[\"x9\"]]\n  \n  output = list(\"col1a1\" = colorTransla(listOut(x[[\"x1\"]]), bigger = TRUE),\n                \"col1a2\" = colorTransla(listOut(x[[\"x1\"]]), bigger = FALSE),\n                \"col2a1\" = colorTransla(x[[\"x3\"]], bigger = TRUE), \n                \"col2a2\" = colorTransla(x[[\"x3\"]], bigger = FALSE),\n                \"col3a1\" = \"grey\", \n                \"col3a2\" = colorTransla(x[[\"x4\"]], bigger = TRUE), \n                \"col3a3\" = colorTransla(x[[\"x2\"]], minp = 0.2),\n                \"col3a4\" = colorTransla(x[[\"x2\"]], minp = 0.2),\n                \n                \"text1a1\" = \"Shapiro-Wilks\",\n                \"text1a2\" = \"Correlation\",\n                \"text2a1\" = \"F-Test\",\n                \"text2a2\" = \"Anova Test\",\n                \"text3a1\" = \"Student t-test\",\n                \"text3a2\" = \"Welch's t-test\",\n                \"text3a3\" = \"Wilcoxon Test\",\n                \"text3a4\" = \"PCA\",\n                \"text4a1\" = \"glm AIC values\",\n                \n                \"textBox1a1\" = \"normal distributed if > 0.05 \",\n                \"textBox1a2\" = \"indicates simple correlation\",\n                \"textBox2a1\" = \"paired variance if > 0.05 | normal\",\n                \"textBox2a2\" = \"paired variance if > 0.05 | non normal\",\n                \"textBox3a1\" = \"for non paired variance datasets\",\n                \"textBox3a2\" = \"for paired variance datasets\",\n                \"textBox3a3\" = \"tests non normal datasets\",\n                \"textBox3a4\" = \"to reduce dimensionality\",\n                \"textBox4a1\" = \"to find regression coefficients\",\n                \n                \"names\" = colNames,\n                \"dataName\" = dataSetName,\n                \"method\" = as.character(method),\n                \n                \"inputNames1a1\" = x1,\n                \"inputNames1a2\" = x2,\n                \"inputNames2a1\" = x3,\n                \"inputNames2a2\" = x4,\n                \"inputNames3a1\" = x5,\n                \"inputNames3a2\" = x6,\n                \"inputNames3a3\" = x7,\n                \"inputNames3a4\" = x8,\n                \"inputNames4a1\" = x9\n  )\n  return(output)\n}\n\n#' splitts calculation in paired and unpaired sections\n#' @param method is the method parameter and the \n#' @param input is the data.frame\n#' @return returns the statistical calculations for each section\nmethodChoice <- function(method,x){\n  output = switch(method,\n                  unPaired = unPairedTest(x),\n                  paired = pairedTest(x))\n  return(output)\n}\n\n#' Output for only paired tests\n#' @param input taking the output of all statistical methods\n#' @return extacts p value of all paired tests and adds them to data.frame\npairedTest <- function(input){\n  welchT %<-% welchTest(input, paired = TRUE)\n  studentTest %<-% studentt(input, paired = TRUE)\n  shapiroT %<-% shapiroT(input)\n  corT %<-% corTest(input)\n  anovaT %<-% anovaTest(input)\n  f.test %<-% fTest(input)\n  wilco %<-% wilcoxonTest(input, paired = TRUE)\n  pcaT %<-% pcaReduce(input)\n  glmT %<-% glmTest(input)\n  \n  output = list(\"x1\" = shapiroT,\n                \"x2\" = corT,\n                \"x3\" = f.test,\n                \"x4\" = anovaT,\n                \"x5\" = studentTest,\n                \"x6\" = welchT,\n                \"x7\" = wilco,\n                \"x8\" = pcaT,\n                \"x9\" = glmT)\n  \n  return(output)\n}\n\n#' Output for only un-paired tests\n#' @param input taking the output of all statistical methods\n#' @return extacts p value of all un-paired tests and adds them to data.frame\nunPairedTest <- function(input){\n  welchT %<-% welchTest(input)\n  studentTest %<-% studentt(input)\n  shapiroT %<-% shapiroT(input)\n  corT %<-% corTest(input)\n  anovaT %<-% anovaTest(input)\n  f.test %<-% fTest(input)\n  wilco %<-% wilcoxonTest(input)\n  pcaT %<-% pcaReduce(input)\n  glmT %<-% glmTest(input)\n  \n  output = list(\"x1\" = shapiroT,\n                \"x2\" = corT,\n                \"x3\" = f.test,\n                \"x4\" = anovaT,\n                \"x5\" = studentTest,\n                \"x6\" = welchT,\n                \"x7\" = wilco,\n                \"x8\" = pcaT,\n                \"x9\" = glmT)\n            \n  return(output)\n}\n\n#' @title disc.normal() \n#' @param x A data.frame or data.table\n#' @return showing shapiro.test output of the data.frame\n#' @export\ndisc.normal <- function(x){\n  data = lapply(x, shapiro.test)\n  pval = c()\n  for(i in 1:length(names(data))){\n    pval = c(pval,data[[names(data)[i]]]$p.value)\n  }\n  \n  nameColumn = names(x)\n  output = data.frame(\"nameColumn\" = nameColumn, \"pvalue\" = pval)\n  output$isNormalDistributed[output$pvalue > 0.05] = TRUE\n  output$isNormalDistributed[output$pvalue < 0.05] = FALSE\n  \n  #call d3.js graphic function via htmlwidgets here\n  return(output)\n}",
    "created" : 1471270569898.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "398793533",
    "id" : "A97F60EC",
    "lastKnownWriteTime" : 1471730763,
    "last_content_update" : 1471730763490,
    "path" : "~/Discovr/R/discovr.R",
    "project_path" : "R/discovr.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}