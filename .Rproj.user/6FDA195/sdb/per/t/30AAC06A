{
    "collab_server" : "",
    "contents" : "#' Statistical Functions\n#' @include discovr.R\n#' Welchs two sample T.Test\n#' @param input A data.frame or data.table\n#' @return indicates whether parameter are from same population - with different variances. \n#' the logic of the function syntax was fount at http://www.sthda.com/english/wiki/matrix-of-student-t-test\nwelchTest <- function(inp, ...) {\n  inp <- as.matrix(inp)\n  n = ncol(inp)\n  p.inp = matrix(NA, n, n)\n  diag(p.inp) = 1\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      test = t.test(inp[, i], inp[, j], ...)\n      p.inp[i, j] <- p.inp[j, i] <- test$p.value\n    }\n  }\n  colnames(p.inp) <- rownames(p.inp) <- colnames(inp)\n  signif(p.inp,3)\n}\n\n#' student t test\n#' @param input A data.frame or data.table\n#' @return indicates whether parameters are from same population - with equal variances. \nstudentt <- function(inp, ...) {\n  inp <- as.matrix(inp)\n  n = ncol(inp)\n  p.inp = matrix(NA, n, n)\n  diag(p.inp) = 1\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      test = t.test(inp[, i], inp[, j], ..., var.equal = TRUE)\n      p.inp[i, j] <- p.inp[j, i] <- test$p.value\n    }\n  }\n  colnames(p.inp) <- rownames(p.inp) <- colnames(inp)\n  signif(p.inp,3)\n}\n\n#' Shapiro Wilks Test\n#' @param input A data.frame or data.table\n#' @return indicates normal distribution\nshapiroT <- function(x){\n  resultVec = c()\n  shapTest = lapply(x, shapiro.test)\n  for(i in 1:length(x)){\n    resultVec = c(resultVec, shapTest[[i]]$p.value)\n  }\n  preOutput = data.frame(\"name\" = names(x),\"size\" = resultVec)\n  output = toJSON(list(\"name\" = \"query\", \"children\" = preOutput), pretty = TRUE)\n  return(output)\n}\n\n#' Correlation Test\n#' @param input A data.frame or data.table\n#' @return indicates correlation between parameters\n  corTest <- function(input){\n  output = cor(input, use = \"complete.obs\")\n  \n  return(output)\n}\n\n#' Anova Test\n#' @param input A data.frame or data.table\n#' @return analyzes the variance of the given samples\nanovaTest <- function(inp, ...) {\n  inp <- as.matrix(inp)\n  n = ncol(inp)\n  p.inp = matrix(NA, n, n)\n  diag(p.inp) = 1\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      test = aov(inp[, i] ~ inp[, j])\n      p.inp[i, j] <- p.inp[j, i] <- test$coefficients[2]\n    }\n  }\n  colnames(p.inp) <- rownames(p.inp) <- colnames(inp)\n  signif(p.inp,3)\n}\n\n#' Chi Square Test\n#' @param input A data.frame or data.table\n#' @return analyzes goodness of fit of fittet line to dataset\nchiSQTest <- function(inp, ...) {\n  inp <- as.matrix(inp)\n  n = ncol(inp)\n  p.inp = matrix(NA, n, n)\n  diag(p.inp) = 1\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      test = chisq.test(inp[, i], inp[, j])\n      p.inp[i, j] <- p.inp[j, i] <- test$p.value\n    }\n  }\n  colnames(p.inp) <- rownames(p.inp) <- colnames(inp)\n  signif(p.inp,3)\n}\n\n#' Wilcoxon Test\n#' @param input A data.frame or data.table\n#' @return Alternative test for the paired t-test if data is not normal - on dependend samples\nwilcoxonTest <- function(inp, ...) {\n  inp <- as.matrix(inp)\n  n = ncol(inp)\n  p.inp = matrix(NA, n, n)\n  diag(p.inp) = 1\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      test = wilcox.test(inp[, i], inp[, j], exact = FALSE,  ...)\n      p.inp[i, j] <- p.inp[j, i] <- test$p.value\n    }\n  }\n  colnames(p.inp) <- rownames(p.inp) <- colnames(inp)\n  signif(p.inp,3)\n}\n\n#' Mann-Whitney U test - Wilcoxon sum rank test\n#' @param input A data.frame or data.table\n#' @return Alternative test for the paired t-test if data is not normal - on independent samples\nmannWhitTest <- function(inp, ...) {\n  inp <- as.matrix(inp)\n  n = ncol(inp)\n  p.inp = matrix(NA, n, n)\n  diag(p.inp) = 1\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      test = wilcox.test(inp[, i], inp[, j], ..., paired = FALSE)\n      p.inp[i, j] <- p.inp[j, i] <- test$p.value\n    }\n  }\n  colnames(p.inp) <- rownames(p.inp) <- colnames(inp)\n  signif(p.inp,3)\n}\n\n#' PCA dimension reduction\n#' @param input A data.frame or data.table\n#' @return shows if datadimensionality can be reduced\n#' indicates which percentage of all principal components that have a sigma value > 0.5\npcaReduce <- function(input){\n  pc = prcomp(x = mtcars, scale. = TRUE)\n  names = colnames(pc$rotation)\n  resultVec = pc$sdev\n  \n  preOutput = data.frame(\"name\" = names,\"size\" = resultVec)\n  output = toJSON(list(\"name\" = \"query\", \"children\" = preOutput), pretty = TRUE)\n  \n  return(output)\n}\n\n#' F-Test\n#' @param input A data.frame or data.table\n#' @return compares variances of the samples - only normal distribution\nfTest <- function(inp, ...) {\n  inp <- as.matrix(inp)\n  n = ncol(inp)\n  p.inp = matrix(NA, n, n)\n  diag(p.inp) = 1\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      test = var.test(inp[, i], inp[, j])\n      test = as.numeric(test$statistic)\n      p.inp[i, j] <- p.inp[j, i] <- test\n    }\n  }\n  colnames(p.inp) <- rownames(p.inp) <- colnames(inp)\n  signif(p.inp,3)\n}\n\n#' GLM\n#' @param input A data.frame or data.table\n#' @return generalized linear model\nglmTest <- function(input){\n  formVec = c()\n  for(i in 1:length(input)) {\n    formVec = c(formVec, glm(input[[i]] ~ ., data = input)$aic)\n  }\n  preOutput = data.frame(\"name\" = colnames(input),\"size\" = abs(formVec))\n  output = toJSON(list(\"name\" = \"query\", \"children\" = preOutput), pretty = TRUE)\n  return(output)\n}",
    "created" : 1471270568546.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4121988966",
    "id" : "30AAC06A",
    "lastKnownWriteTime" : 1471729941,
    "last_content_update" : 1471729941582,
    "path" : "~/Discovr/R/statisticFun.R",
    "project_path" : "R/statisticFun.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}