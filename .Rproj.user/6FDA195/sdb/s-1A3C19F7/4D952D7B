{
    "collab_server" : "",
    "contents" : "#' @title discovr() \n#' @param x A data.frame or data.table\n#' @param method The method indicates \"paired\" or \"unpaired\" testing\n#' @param preset As preset mutliple techniques are allowed, such as \"FACS\" or \"FRAP\".\n#' @param style A style input such as \"heatmap\" / \"cleveland\" / \"ternary\" \n#' @return The calculation output\n#' @include graphics.R\n#' @include statisticFun.R\n#' @import future\n#' @import ggtern\n#' @examples \n#' library(Discovr)\n#' disc(mtcars[1:2])\n#' @export\ndisc <- function(x, method = \"unpaired\", preset = NULL, style = \"heatmap\"){\n  method = as.character(method)\n  input = as.data.frame(x)\n  cols = length(input)\n  if(!is.null(preset)) presetApp = as.character(preset)\n  \n  library(d3heatmap)\n  library(future)\n  \n  if(cols == 2) {\n    if(is.null(preset)){\n      if(method == \"paired\") data = pairedTest(x) else data = unPairedTest(x)\n    } else if(presetApp == \"facs\" | presetApp == \"FACS\") {\n      cat(\"performing FACS preset analysis\")\n    } else if(presetApp == \"frap\" | presetApp == \"FRAP\") {\n      cat(\"performing FRAP preset analysis\")\n    } else {\n      cat(\"disc() input not recognized - check type errors\")\n    }\n  } else if(cols > 2) {\n    cat(\"multi column analysis\")\n    data = multicol(data)\n  } else {\n    cat(\"problem with data input\")\n  }\n  \n  if(exists(\"data\")){\n    plotFun(data,style)\n  } else {return(\"sry something went wront\")}\n\n  \n}\n\n#' Output for only paired tests\n#' @param input taking the output of all statistical methods\n#' @return extacts p value of all paired tests and adds them to data.frame\npairedTest <- function(input){\n  \n  shapiroT %<-% shapiroTest(input)\n  corT %<-% corTest(input)\n  chiT %<-% chiSQTest(input)\n  manwiT %<-% mannWhitTest(input) \n  wilcoT %<-% wilcoxonTest(input) \n  anovaT %<-% anovaTest(input)\n  \n  #create data.frame ordered by test function\n  \n  return(output)\n}\n\n#' Output for only un-paired tests\n#' @param input taking the output of all statistical methods\n#' @return extacts p value of all un-paired tests and adds them to data.frame\nunPairedTest <- function(input){\n  \n  welchT %<-% welchTest(input)\n  #shapiroT = shapiroTest(input)\n  corT %<-% corTest(input)\n  chiT %<-% chiSQTest(input)\n  #anovaT = anovaTest(input)\n  \n  dataComp = data.frame()\n  dataComp[1,1] = welchT$p.value\n  dataComp[1,2] = corT\n  dataComp[1,3] = chiT\n  \n  #just some added columns as space filler for now\n  dataComp[2,2] = welchT$p.value\n  dataComp[2,3] = corT\n  dataComp[2,1] = chiT\n  \n  colnames(dataComp) = c(\"Welch\",\"Correlation\",\"Chi Square\")\n  output = dataComp\n  \n  #create data.frame ordered by test function\n  \n  return(output)\n}\n\n#' @title multicol\n#' @param x A data.frame or data.table\n#' @return performing muliple calculations on a data frame with multiple columns\n\nmulticol <- function(x){\n  shapiroTest = disc.normal(x)\n  corTest = cor(x, use = \"complete.obs\") \n  varTest = var(x, na.rm = TRUE)\n  matrixttest = t.test.matrix(x)\n  \n  output = list(\"t.test\" = matrixttest, \"correlation\" = corTest, \"variance\" = varTest, \"shapiro\" = shapiroTest)\n  return(output)\n}\n\n#' @title disc.normal() \n#' @param x A data.frame or data.table\n#' @return showing shapiro.test output of the data.frame\n#' \ndisc.normal <- function(x){\n  data = lapply(x, shapiro.test)\n  pval = c()\n  for(i in 1:length(names(data))){\n    pval = c(pval,data[[names(data)[i]]]$p.value)\n  }\n  \n  nameColumn = names(x)\n  output = list(\"pvalue\" = pval, \"nameColumn\" = nameColumn)\n  \n  #call d3.js graphic function via htmlwidgets here\n  \n  return(output)\n}\n\n#' @title t-test matrix function \n#' @param x A data.frame or data.table\n#' @return returns the p value matrix of t.tests\n#' this code function was found at http://www.sthda.com/english/wiki/matrix-of-student-t-test\nt.test.matrix <- function(mat, ...) {\n  mat <- as.matrix(mat)\n  n = ncol(mat)\n  p.mat = matrix(NA, n, n)\n  diag(p.mat) = 1\n  for (i in 1:(n - 1)) {\n    for (j in (i + 1):n) {\n      test = t.test(mat[, i], mat[, j], ...)\n      p.mat[i, j] <- p.mat[j, i] <- test$p.value\n    }\n  }\n  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)\n  signif(p.mat,3)\n}",
    "created" : 1469555524673.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3104126194",
    "id" : "4D952D7B",
    "lastKnownWriteTime" : 1470259770,
    "last_content_update" : 1470259770287,
    "path" : "~/Discovr/R/discovr.R",
    "project_path" : "R/discovr.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}